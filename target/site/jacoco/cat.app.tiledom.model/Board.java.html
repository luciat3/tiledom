<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="es"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Board.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">practiques-tqs</a> &gt; <a href="index.source.html" class="el_package">cat.app.tiledom.model</a> &gt; <span class="el_source">Board.java</span></div><h1>Board.java</h1><pre class="source lang-java linenums">package cat.app.tiledom.model;

public class Board {

    // extraiem el generador per poder aplicar el mock als tests
    private RandomTileGenerator genRandom;

    //mida segons nivell de dificultat -&gt; generarà un taulell tiles[size][size]
    private int size;
    //valor 0 -&gt; no hi ha peça 
    //valors 1-10 -&gt; diferents tipus de peces
    private int tiles[][];

    // --------------------- Funcions inicialització taulell -----------------------------
<span class="fc" id="L15">    public Board() { throw new IllegalArgumentException(&quot;Falten variables per inicialitzar el taulell&quot;); }</span>
    // funció que inicialitzi el taulell d'una mida variable segons la dificultat i les peces col·locades aleatòriament
<span class="fc" id="L17">    public Board(int dificultat, RandomTileGenerator gen) {</span>
<span class="pc bpc" id="L18" title="1 of 4 branches missed.">        if (dificultat &lt; 1 || dificultat &gt; 3) throw new IllegalArgumentException(&quot;Dificultat fora de rang (1–3)&quot;);</span>

<span class="fc" id="L20">        this.genRandom = gen;</span>

<span class="fc" id="L22">        int numTipus = 0, numPeces = 0;</span>
        // mida i peces segons dificultat
<span class="pc bpc" id="L24" title="1 of 4 branches missed.">        switch (dificultat) {</span>
<span class="fc" id="L25">            case 1 -&gt; {size = 8; numTipus = 5; numPeces = 40;}</span>
<span class="fc" id="L26">            case 2 -&gt; {size = 10; numTipus = 7; numPeces = 60;}</span>
<span class="fc" id="L27">            case 3 -&gt; {size = 12; numTipus = 10; numPeces = 90;}</span>
        }
<span class="fc" id="L29">        tiles = new int[size][size];</span>
<span class="fc" id="L30">        setTiles(size, numTipus, numPeces);</span>


<span class="fc" id="L33">    }</span>

    public int getSize(){
<span class="fc" id="L36">        return size;</span>
    }

    public int[][] getTiles(){
<span class="fc" id="L40">        return tiles;</span>
    }

    public void setTiles(int[][] tiles) {
<span class="fc" id="L44">        this.tiles = tiles;</span>
<span class="fc" id="L45">        this.size = tiles.length;</span>
<span class="fc" id="L46">    }</span>

    public void setTiles(int size, int numTipus, int numPeces){
<span class="fc" id="L49">        int side = (int) Math.ceil(Math.sqrt(numPeces)); // costat mínim que pot contenir totes les peces</span>

        // Calculem l'offset per centrar el bloc
<span class="fc" id="L52">        int start = (size - side) / 2;</span>
<span class="fc" id="L53">        int end = start + side;</span>

        // Omplim les peces dins del bloc central
<span class="fc" id="L56">        int placed = 0;</span>
<span class="pc bpc" id="L57" title="1 of 4 branches missed.">        for (int i = 0; i &lt; size &amp;&amp; placed &lt; numPeces; i++) {</span>
<span class="fc bfc" id="L58" title="All 4 branches covered.">            for (int j = 0; j &lt; size &amp;&amp; placed &lt; numPeces; j++) {</span>
                // només col·loca peces si la posició està dins del bloc central
                // i una petita probabilitat extra si és al voltant
<span class="pc bpc" id="L61" title="1 of 8 branches missed.">                boolean insideCenter = i &gt;= start &amp;&amp; i &lt; end &amp;&amp; j &gt;= start &amp;&amp; j &lt; end;</span>
<span class="pc bpc" id="L62" title="1 of 4 branches missed.">                if (insideCenter || (Math.random() % 5 == 0)) { </span>
<span class="fc" id="L63">                    int value = genRandom.genera();</span>
<span class="fc" id="L64">                    tiles[i][j] = value;</span>
<span class="fc" id="L65">                    placed++;</span>
                }

            }
        }
<span class="fc" id="L70">    }</span>

    // ------------------ Funcions Game Session -----------------------------

    // Comprova si les peces seleccionades tenen al menys un lateral lliure
    // que no siguin posicions lliures
    // i si les dues són del mateix tipus
    public boolean tryMatch(int x1, int y1, int x2, int y2) {
        // son buides
<span class="pc bpc" id="L79" title="1 of 4 branches missed.">        if (tiles[x1][y1] == 0 || tiles[x2][y2] == 0) return false;</span>
        // son de diferent tipus
<span class="fc bfc" id="L81" title="All 2 branches covered.">        if (tiles[x1][y1] != tiles[x2][y2]) return false;</span>
        // és la mateixa peça
<span class="pc bpc" id="L83" title="1 of 4 branches missed.">        if (x1 == x2 &amp;&amp; y1 == y2) return false;</span>
        
        // tenen al menys un costat buit
<span class="fc" id="L86">        boolean firstFree = isSideFree(x1, y1);</span>
<span class="fc" id="L87">        boolean secondFree = isSideFree(x2, y2);</span>
<span class="pc bpc" id="L88" title="1 of 4 branches missed.">        if (!(firstFree &amp;&amp; secondFree)) return false;</span>

<span class="fc" id="L90">        tiles[x1][y1] = 0;</span>
<span class="fc" id="L91">        tiles[x2][y2] = 0;</span>
<span class="fc" id="L92">        return true;</span>
    }

    // Funció auxiliar per comprovar si tenen un costat buit
    private boolean isSideFree(int i, int j) {
        // si és fora del taulell també és lliure
<span class="fc bfc" id="L98" title="All 4 branches covered.">        boolean leftFree  = (j - 1 &lt; 0) || tiles[i][j - 1] == 0;</span>
<span class="fc bfc" id="L99" title="All 4 branches covered.">        boolean rightFree = (j + 1 &gt;= tiles[i].length) || tiles[i][j + 1] == 0;</span>
<span class="fc bfc" id="L100" title="All 4 branches covered.">        return leftFree || rightFree;</span>
    }

    // Comprova si queden peces al taulell
    public boolean isEmpty() {
<span class="fc bfc" id="L105" title="All 2 branches covered.">        for (int i = 0; i &lt; size; i++) {</span>
<span class="fc bfc" id="L106" title="All 2 branches covered.">            for (int j = 0; j &lt; size; j++) {</span>
<span class="fc bfc" id="L107" title="All 2 branches covered.">                if (tiles[i][j] != 0) return false;</span>
            }
        }
<span class="fc" id="L110">        return true;</span>
    }
    
    // Comprova si queden moviments disponibles al taulell
    public boolean hasAvailableMoves() {

        //recorrem tot el taulell
<span class="fc bfc" id="L117" title="All 2 branches covered.">        for (int i = 0; i &lt; size; i++) {</span>
<span class="fc bfc" id="L118" title="All 2 branches covered.">            for (int j = 0; j &lt; size; j++) {</span>
<span class="fc" id="L119">                int current = tiles[i][j];</span>
                //ignorem les buides
<span class="fc bfc" id="L121" title="All 2 branches covered.">                if (current == 0) continue;</span>

                //seleccionem les peces amb costats lliures
<span class="pc bpc" id="L124" title="1 of 2 branches missed.">                if (isSideFree(i, j)) {</span>
                    //busquem si hi ha una del mateix tipus amb costat lliure
<span class="fc bfc" id="L126" title="All 2 branches covered.">                    for (int x = 0; x &lt; size; x++) {</span>
<span class="fc bfc" id="L127" title="All 2 branches covered.">                        for (int y = 0; y &lt; size; y++) {</span>
<span class="fc bfc" id="L128" title="All 6 branches covered.">                            if ((x == i &amp;&amp; y == j) || tiles[x][y] == 0) continue;</span>
<span class="pc bpc" id="L129" title="1 of 4 branches missed.">                            if (tiles[x][y] == current &amp;&amp; isSideFree(x, y)) {</span>
<span class="fc" id="L130">                                return true; //hi ha al menys una jugada disponible</span>
                            }
                        }
                    }
                }
            }
        }
<span class="fc" id="L137">        return false; </span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>